这是参考清华大学的[rCore-Tutorial-Book](https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html)课程实现的内核。有详尽的注释和README，方便理解和回顾。可将本项目当作学习笔记使用。

## 运行

在根目录下，执行

- `make docker`：进入Docker环境。该环境安装了qemu、rust、cargo等工具。
- `make run`：进入Docker环境，并启动Qemu模拟器，运行内核。

在Docker环境中，切换到`os`目录下，可执行命令：

- `make run`：运行内核。
- `make dbgserver`：运行内核，并启动GDB调试服务器（监听端口`1234`）。
- `make dbgclient`：连接GDB调试服务器，连接到内核进程。

## 实现的功能

本项目会编译到目标平台`riscv64gc-unknown-none-elf`。`unknown`表示该目标平台不使用操作系统，`elf`表示编译出来的文件是ELF格式。

### 1. 基本的执行环境

使用Qemu模拟RISC-V计算机。计算机启动时，控制权的变化为：

1. 硬件：由硬件固化的汇编程序负责，执行初始化后，将控制权交给`0x80000000`地址上的程序；
2. bootloader：引导程序。该程序需要被加载到`0x80000000`，做相关的初始化工作后，并将控制权交给`0x80200000`地址上的程序。我们用的RustSBI就属于这个角色。
3. 内核：最终接管计算机的控制权。内核必须被加载进`0x80200000`地址处。

还需要定义内核的内存布局：

- 入口函数是`_start`，由汇编代码（[`entry.asm`](./os/src/entry.asm)）编写。它会进入Rust方法`rust_main`，打印`Hello, world!`。
- 链接脚本（[`linker.ld`](./os/src/linker.ld)）定义内存布局。需要注意的是，启动时要将`.bss`段清零。
- 要让`0x80200000`处的第一条指令，是入口函数`_start`，才能保证控制权的交接。
  - 直接使用`cargo build --release`编译出来的ELF文件是不行的，因为它还携带头信息和符号表。
  - 需要用`rust-objcopy`工具裁剪（strip）它们，才能使第一条指令在内核内存段的初始位置。

此外，内核处于Supervisor特权级别，而RustSBI处于更高的Machine特权级别。内核需要借助RustSBI提供的SBI接口，才能操作硬件。这里使用了库`sbi-rt`提供的SBI接口封装。

### 2. 批处理程序

在早期的计算机系统中，用户每次只能加载一个程序到内存中。等上一个执行完后，才能加载下一个。而批处理操作系统，允许用户一次性加载多个程序到内存，让操作系统依次执行它们。

批处理系统如何批量加载程序，并依次运行？本项目的实现：

1. 在内核启动时，先将所有程序的二进制，都加载进内核的`.data`区。同时记录各个程序的内存起始和结束位置。
2. 内核要选择程序执行时：
   1. 先在`.data`区找到程序的二进制代码
   2. 将它们复制到内核的`.text`区（具体是`0x80400000`处，这是系统约定的程序起始位置）

用户程序位于User特权级别，而内核位于Supervisor特权级别。程序调用系统调用时，会触发Trap，从User模式（用户态）进入Supervisor模式（内核态）。这样才能执行Supervisor级别的指令。

硬件层面，有一些跟处理Trap相关的控制寄存器CSR（Control and Status Register）：

| CSR       | 功能                                                |
| --------- | --------------------------------------------------- |
| `sstatus` | 记录 Trap 发生之前，CPU 处在哪个特权级（S/U）等信息 |
| `spec`    | 记录 Trap 发生之前，执行的最后一条指令的地址        |
| `scause`  | 描述 Trap 的原因                                    |
| `stval`   | 给出 Trap 附加信息                                  |
| `stvec`   | 控制 Trap 处理代码的入口地址                        |

可以编写自己的处理Trap的入口方法，并将它的地址设给CSR寄存器`stvec`。遇到Trap后，CPU就会自动跳转到该地址，进入该方法。

程序进行一次系统调用的流程如下：

1. 程序调用`ecall`指令，在寄存器`a0`/`a2`/`a3`（`x10`/`x11`/`x12`）中传递参数。该指令将触发Trap。
2. CPU切换到S模式，进入处理Trap的入口方法`__alltraps`。它将保存程序的上下文（即当前寄存器的值）到内核栈上。
3. `__alltraps`方法最后调用Rust的`trap_handler`方法，根据Trap的类型，执行不同的逻辑。
4. 调用汇编方法`__restore`（但不是必要的，由trap分支决定）。该方法主要做：
   - 内核栈上保存着程序的上下文，将它们恢复到寄存器上；
   - 执行`sret`指令。该指令会切换回U模式，并将`spec`寄存器的值写入到`pc`寄存器（指向要执行的下一条指令），从而将控制权交还给程序。

要保存/恢复的上下文（用类型`TrapContext`表示），包括这些寄存器：

- 通用寄存器`x0`~`x31`
- CSR寄存器`sstatus`
- CSR寄存器`sepc`
